<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>开发指南_网易七鱼</title>
	<link rel="stylesheet" href="./css/doc.css">
	<link rel="stylesheet" href="./css/fit.css">
	<link rel="stylesheet" href="./css/solarized-light.css">
	<style>
		.m-header .logo{
			width: 222px;
		}
		.m-header .logo img{
			width: 120px;
		}
		.m-header .nav li {
			padding: 22px 7px;
		}
	</style>
	<script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?392534319c7c718ea324b5d3b4d0127d";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
	</script>
    
</head>
<body>

<div class="g-hd">
	<div class="g-fit">
		<div class="m-header">
			<div class="logo">
				<a href="/"><img src="./img/logo.png" alt="logo"></a>
				<span>开发指南</span>
			</div>
			<div class="nav">
				<ul>
                    
					<li>
                        
						<a href='/guide'>
                            首页
						</a>
                        
					</li>
                    
					<li>
                        
						<a href='./Web_SDK_Guide.html'>
                            Web
						</a>
                        
					</li>
                    
					<li>
                        
						<a href='./iOS_SDK_Guide.html'>
                            iOS
						</a>
                        
					</li>
                    
					<li>
                        
						<a class="z-sel" href='./Android_SDK_Guide.html'>
                            Android
						</a>
                        
					</li>
                    
					<li>
                        
						<a href='./qiyu_crm_interface.html'>
                            企业信息对接
						</a>
                        
					</li>
                    
					<li>
                        
						<a href='./message_interface.html'>
                            消息接口文档
						</a>
                        
					</li>
                    
					<li>
                        
						<a href='./worksheet_open_api.html'>
                            工单接口文档
						</a>
                        
					</li>
                    
					<li>
                        
						<a href='./Platform_OpenAPI.html'>
                            平台接入
						</a>
                        
					</li>
                    
				</ul>
			</div>
		</div>
	</div>
</div>

<div class="g-box">
	<div class="g-nav j-nav"><ul class="m-nav"><li><h2><a href="#简介" class="j-flag-levone">简介</a></h2><i class="u-icon u-icon-down j-flag-icon"></i></li><li><h2><a href="#快速集成" class="j-flag-levone">快速集成</a></h2><i class="u-icon u-icon-down j-flag-icon"></i></li><li><h2><a href="#SDK包具体内容" class="j-flag-levone">SDK包具体内容</a></h2><i class="u-icon u-icon-down j-flag-icon"></i></li><li><h2><a href="#混淆配置" class="j-flag-levone">混淆配置</a></h2><i class="u-icon u-icon-down j-flag-icon"></i></li><li><h2><a href="#初始化" class="j-flag-levone">初始化</a></h2><i class="u-icon u-icon-down j-flag-icon"></i></li><li><h2><a href="#消息" class="j-flag-levone">消息</a></h2><ul class="nav_levtwo"><li><h3><a href="#新消息提醒">新消息提醒</a></h3></li><li><h3><a href="#清除缓存文件">清除缓存文件</a></h3></li></ul><i class="u-icon u-icon-down j-flag-icon"></i></li><li><h2><a href="#定制界面" class="j-flag-levone">定制界面</a></h2><ul class="nav_levtwo"><li><h3><a href="#客服窗口UI自定义">客服窗口UI自定义</a></h3></li><li><h3><a href="#其他界面">其他界面</a></h3></li><li><h3><a href="#人工客服快捷入口">人工客服快捷入口</a></h3></li></ul><i class="u-icon u-icon-down j-flag-icon"></i></li><li><h2><a href="#关联商户用户信息" class="j-flag-levone">关联商户用户信息</a></h2><ul class="nav_levtwo"><li><h3><a href="#关联用户和资料">关联用户和资料</a></h3></li><li><h3><a href="#注销">注销</a></h3></li></ul><i class="u-icon u-icon-down j-flag-icon"></i></li><li><h2><a href="#自定义客服分配" class="j-flag-levone">自定义客服分配</a></h2><ul class="nav_levtwo"><li><h3><a href="#指定客服（组）">指定客服（组）</a></h3></li><li><h3><a href="#指定机器人">指定机器人</a></h3></li><li><h3><a href="#汇报商品信息">汇报商品信息</a></h3></li><li><h3><a href="#设置用户VIP等级">设置用户VIP等级</a></h3></li><li><h3><a href="#控制会话过程">控制会话过程</a></h3></li></ul><i class="u-icon u-icon-down j-flag-icon"></i></li><li><h2><a href="#图片加载" class="j-flag-levone">图片加载</a></h2><ul class="nav_levtwo"><li><h3><a href="#UniversalImageLoader实现">UniversalImageLoader实现</a></h3></li><li><h3><a href="#fresco实现">fresco实现</a></h3></li><li><h3><a href="#Glide实现">Glide实现</a></h3></li><li><h3><a href="#Picasso实现">Picasso实现</a></h3></li></ul><i class="u-icon u-icon-down j-flag-icon"></i></li><li><h2><a href="#省电策略" class="j-flag-levone">省电策略</a></h2><ul class="nav_levtwo"><li><h3><a href="#配置推送服务器地址">配置推送服务器地址</a></h3></li><li><h3><a href="#推送消息数据结构">推送消息数据结构</a></h3></li></ul><i class="u-icon u-icon-down j-flag-icon"></i></li><li><h2><a href="#自定义响应事件" class="j-flag-levone">自定义响应事件</a></h2><ul class="nav_levtwo"><li><h3><a href="#URL链接点击响应">URL链接点击响应</a></h3></li></ul><i class="u-icon u-icon-down j-flag-icon"></i></li><li><h2><a href="#平台商家企业" class="j-flag-levone">平台商家企业</a></h2><ul class="nav_levtwo"><li><h3><a href="#指定商家">指定商家</a></h3></li><li><h3><a href="#商家入口和最近联系商家入口">商家入口和最近联系商家入口</a></h3></li><li><h3><a href="#最近联系商家列表">最近联系商家列表</a></h3></li><li><h3><a href="#获取商家信息">获取商家信息</a></h3></li></ul><i class="u-icon u-icon-down j-flag-icon"></i></li><li><h2><a href="#变更记录" class="j-flag-levone">变更记录</a></h2><ul class="nav_levtwo"><li><h3><a href="#V3.13.0(2017-12-26)">V3.13.0(2017-12-26)</a></h3></li><li><h3><a href="#V3.12.0(2017-11-16)">V3.12.0(2017-11-16)</a></h3></li><li><h3><a href="#V3.11.1(2017-10-17)">V3.11.1(2017-10-17)</a></h3></li><li><h3><a href="#V3.10.0(2017-09-07)">V3.10.0(2017-09-07)</a></h3></li><li><h3><a href="#V3.9.5(2017-08-15)">V3.9.5(2017-08-15)</a></h3></li><li><h3><a href="#V3.9.0(2017-07-20)">V3.9.0(2017-07-20)</a></h3></li><li><h3><a href="#V3.7.1(2017-06-22)">V3.7.1(2017-06-22)</a></h3></li><li><h3><a href="#V3.7.0(2017-05-24)">V3.7.0(2017-05-24)</a></h3></li><li><h3><a href="#V3.6.1(2017-05-10)">V3.6.1(2017-05-10)</a></h3></li><li><h3><a href="#V3.6.0(2017-04-27)">V3.6.0(2017-04-27)</a></h3></li><li><h3><a href="#V3.5.5(2017-04-10)">V3.5.5(2017-04-10)</a></h3></li><li><h3><a href="#V3.5.0(2017-03-28)">V3.5.0(2017-03-28)</a></h3></li><li><h3><a href="#V3.4.0(2017-02-21)">V3.4.0(2017-02-21)</a></h3></li><li><h3><a href="#V3.3.0(2017-01-20)">V3.3.0(2017-01-20)</a></h3></li><li><h3><a href="#V3.2.0(2017-01-04)">V3.2.0(2017-01-04)</a></h3></li></ul><i class="u-icon u-icon-down j-flag-icon"></i></li></ul></div>
	<div class="g-container j-cnt"><h1 id="网易七鱼 Android SDK 开发指南">网易七鱼 Android SDK 开发指南</h1><h2 id="简介">简介</h2><p>网易七鱼 Android SDK 是一个 Android 端客服系统访客解决方案，既包含了客服聊天逻辑管理，也提供了聊天界面，开发者可方便的将客服功能集成到自己的 APP 中。</p>
<h2 id="快速集成">快速集成</h2><p>只需简单 3 步，即可将客服功能加入你的 APP：</p>
<ol>
<li><p>添加 SDK 到项目中。</p>
<ul>
<li><p>Android Studio: 在工程 build.gradle 文件中添加依赖即可。<a href="https://bintray.com/qiyukf/maven/qiyu-android-sdk/_latestVersion" target="_blank"><img src="https://api.bintray.com/packages/qiyukf/maven/qiyu-android-sdk/images/download.svg" style="width:auto" height=20 width=104 alt='Download' /></a></p>
<pre><code><span class="hljs-comment">// 最新版本可参考 Download 徽章后对应的数值</span>
<span class="hljs-keyword">compile</span> <span class="hljs-string">'com.qiyukf.unicorn:unicorn:3.13.0'</span>
</code></pre></li>
<li><p>Eclipse: 先下载 SDK，然后解压缩，将得到的 unicorn 文件夹作为库工程模块导入到你的工程中，并添加模块依赖。然后将 assets 文件夹的内容拷贝你的主工程的 assets 目录中，将 AndroidManifest 文件中的内容拷贝到你的主工程的 manifest 文件中，并将 manifest 中的 <code>${applicationId}</code> 替换为你的包名。</p>
</li>
</ul>
</li>
<li><p>在你的 Application 类的 <code>onCreate</code> 函数中，加入以下初始化代码：</p>
<pre><code> public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YourApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> </span>{
    public void onCreate() {
        <span class="hljs-comment">// ... your codes</span>
        <span class="hljs-comment">// appKey 可以在七鱼管理系统-&gt;设置-&gt;APP接入 页面找到</span>
        <span class="hljs-type">Unicorn</span>.init(<span class="hljs-keyword">this</span>, <span class="hljs-string">"appKey"</span>, options(), <span class="hljs-keyword">new</span> <span class="hljs-type">UnicornImageLoader</span>());
        <span class="hljs-comment">// ... your codes</span>
    }

    <span class="hljs-comment">// 如果返回值为null，则全部使用默认参数。</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">YSFOptions</span> options() {
        <span class="hljs-type">YSFOptions</span> options = <span class="hljs-keyword">new</span> <span class="hljs-type">YSFOptions</span>();
        options.statusBarNotificationConfig = <span class="hljs-keyword">new</span> <span class="hljs-type">StatusBarNotificationConfig</span>();
        <span class="hljs-keyword">return</span> options;
}
</code></pre><p>上面代码中，UnicornImageLoader 可根据你 APP 中图片加载模块做自定义实现，以免 SDK 中引入第三方图片管理库后造成与 APP 的冲突或者浪费。在 demo 中，实现了依赖于 UniversalImageLoader 的 UILImageLoader。其代码以及依赖于 fresco、Glide、Picasso 的实现代码可参考 <a href="#图片加载">图片加载</a> 一节。</p>
</li>
<li><p>在你的 APP 的合适页面添加客服入口按钮，并在响应函数中加入如下代码：</p>
<pre><code> String title = <span class="hljs-string">"聊天窗口的标题"</span>;
 /**
  * 设置访客来源，标识访客是从哪个页面发起咨询的，用于客服了解用户是从什么页面进入。
  * 三个参数分别为：来源页面的url，来源页面标题，来源页面额外信息（可自由定义）。
  * 设置来源后，在客服会话界面的<span class="hljs-string">"用户资料"</span>栏的页面项，可以看到这里设置的值。
  */
 ConsultSource <span class="hljs-built_in">source</span> = new ConsultSource(<span class="hljs-built_in">source</span>Url, <span class="hljs-built_in">source</span>Title, <span class="hljs-string">"custom information string"</span>);
 /**
  * 请注意： 调用该接口前，应先检查Unicorn.isServiceAvailable()，
  * 如果返回为<span class="hljs-literal">false</span>，该接口不会有任何动作
  *
  * @param context 上下文
  * @param title   聊天窗口的标题
  * @param <span class="hljs-built_in">source</span>  咨询的发起来源，包括发起咨询的url，title，描述信息等
  */
 Unicorn.openServiceActivity(context, title, <span class="hljs-built_in">source</span>);
</code></pre></li>
</ol>
<p>在打开的页面中，用户就可以咨询客服了。</p>
<h2 id="SDK包具体内容">SDK包具体内容</h2><pre><code><span class="hljs-selector-tag">sdk</span>
├── <span class="hljs-selector-tag">libs</span>
│   ├── <span class="hljs-selector-tag">qiyu-sdk-x</span><span class="hljs-selector-class">.y</span><span class="hljs-selector-class">.z</span><span class="hljs-selector-class">.jar</span>
│   └── <span class="hljs-selector-tag">android-support-v4</span><span class="hljs-selector-class">.jar</span>
├── <span class="hljs-selector-tag">res</span>
│   └── ***
└── <span class="hljs-selector-tag">assets</span>
    └── ***
</code></pre><p>上面文件中，qiyu-sdk-x.y.z.jar 是网易七鱼的 SDK 包，res 和 assets 为 SDK 所依赖的资源文件。</p>
<p>android-support-v4.jar 为工程依赖的外部库，所需最低版本为23.0.0（Android 6.0权限管理适配）。如果你的 APP 也依赖了这个 jar 包，可以将你的工程中的依赖移除，或者将这个库移动到一个更基础的库工程中做依赖。如果是使用 Android Studio 接入，SDK 工程的 build.gradle 文件已经添加了依赖，无需理会这个文件。</p>
<h2 id="混淆配置">混淆配置</h2><p>如果你的 apk 最终会经过代码混淆，请在 proguard 配置文件中加入以下代码:</p>
<pre><code>-<span class="ruby">dontwarn com.qiyukf.**
</span>-<span class="ruby">keep <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">qiyukf</span>.** {*;</span>}</span>
</code></pre><h2 id="初始化">初始化</h2><p>网易七鱼 SDK 需要接收消息推送，因此有一个后台进程，进程名为 &quot;packageName:core&quot;。我们知道，Application 的 onCreate 在各个进程中都会被调用，包括 UI 主进程和七鱼的推送进程。在实现 Application 的 onCreate 时，如果需要在 onCreate 中调用除 init 接口外的其他接口，应先判断当前所属进程，并只有在当前是 UI 进程时才调用。SDK 的 init 接口无需做额外判断，SDK 会自动识别是否需要初始化。另外，要注意不要在主进程外的其他进程中再调用 Unicorn 提供的接口（<code>init</code> 除外）。判断当前进程是否是在主进程的代码示例如下：</p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">boolean</span> inMainProcess(Context context) {
    <span class="hljs-keyword">String</span> mainProcessName = context.getApplicationInfo().processName;
    <span class="hljs-keyword">String</span> processName = getProcessName();
    <span class="hljs-keyword">return</span> TextUtils.equals(mainProcessName, processName);
}

<span class="hljs-comment">/**
 * 获取当前进程名
 */</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> getProcessName() {
    <span class="hljs-keyword">BufferedReader</span> reader = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">try</span> {
        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"/proc/"</span> + android.os.Process.myPid() + <span class="hljs-string">"/"</span> + <span class="hljs-string">"cmdline"</span>);
        reader = <span class="hljs-keyword">new</span> <span class="hljs-keyword">BufferedReader</span>(<span class="hljs-keyword">new</span> FileReader(file));
        <span class="hljs-keyword">return</span> reader.readLine().<span class="hljs-built_in">trim</span>();
    } <span class="hljs-keyword">catch</span> (IOException e) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    } <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">if</span> (reader != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">try</span> {
                reader.close();
            } <span class="hljs-keyword">catch</span> (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre><p>初始化包括两个部分，一是本地数据的初始化，二是从七鱼的服务器获取一些配置信息操作。本地数据的初始化是同步的，主要是检查本地是否已经有可以聊天的账号，如果有了，还会做一些缓存数据的初始化操作。如果没有，才会进入到第二部分，去七鱼服务器获取聊天账号。第二部分是异步操作，会在后台自动完成。</p>
<h2 id="消息">消息</h2><h3 id="新消息提醒">新消息提醒</h3><p>当用户不处在聊天界面时，收到客服的消息，APP 应当在通知栏或者聊天入口给出提醒。</p>
<p>通知栏提醒可以显示最近一条消息的内容，并提供给用户快速进入 APP 的入口。要打开通知栏提醒功能，只需给 <code>YSFOptions</code> 的 <code>statusBarNotificationConfig</code> 域赋予非 null 值即可。同时，通过定制该域的各配置项，还能实现提醒开关，免打扰等功能。</p>
<p>要实现点击通知栏提醒直接跳转到会话窗口的功能，需要设置 <code>StatusBarNotificationConfig</code> 的 <code>notificationEntrance</code>，并在对应的 Activity 里添加处理。如果没有设置 <code>notificationEntrance</code>，则是在 <code>AndroidManifest</code> 中设置的入口 Activity 中处理。示例代码如下：</p>
<pre><code><span class="hljs-keyword">Intent</span> <span class="hljs-keyword">intent</span> = getIntent();
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">intent</span>.hasExtra(NimIntent.EXTRA_NOTIFY_CONTENT)) {
    // 打开客服窗口
    Unicorn.openServiceActivity(context, title, source);
    // 最好将<span class="hljs-keyword">intent</span>清掉，以免从堆栈恢复时又打开客服窗口
    setIntent(new <span class="hljs-keyword">Intent</span>());
}
</code></pre><p>在聊天入口的地方，APP 可以给出是否有未读消息，以及未读数的提示。APP 可以通过添加以下监听来跟踪未读数变化，更新界面，反馈给用户：</p>
<pre><code><span class="hljs-comment">// 添加未读数变化监听，add 为 true 是添加，为 false 是撤销监听。</span>
<span class="hljs-comment">// 退出界面时，必须撤销，以免造成资源泄露</span>
<span class="hljs-keyword">private</span> UnreadCountChangeListener listener = <span class="hljs-keyword">new</span> UnreadCountChangeListener() { <span class="hljs-comment">// 声明一个成员变量</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onUnreadCountChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>{
        <span class="hljs-comment">// 在此更新界面, count 为当前未读数，</span>
        <span class="hljs-comment">// 也可以用 Unicorn.getUnreadCount() 获取总的未读数</span>
    }
}

<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addUnreadCountChangeListener</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> add)</span> </span>{
    Unicorn.addUnreadCountChangeListener(listener, add);
}
</code></pre><p>默认情况下，只有访客在聊天界面时，才不会有通知栏提醒，其他界面以及 APP 在后台时，都会有消息提醒。如果当 APP 在前台时，不需要通知栏提醒新消息，可以调用<code>Unicorn.toggleNotification(false)</code>关闭消息提醒，然后在 APP 退到后台时，调用<code>Unicorn.toggleNotification(true)</code>重新打开。</p>
<p>用户收到新消息后（通过未读数变化监听接口可获知此事件），如果开发者需要显示新收到的消息，可通过下面接口获取最近一条消息：</p>
<pre><code>/**
 * 获取和客服的最后一条聊天消息内容。
 * 可用于未读消息变化时，展示最后一条未读消息，或者展示客服的最后一条消息。
 * @<span class="hljs-keyword">return</span> 最后一条消息
 */
UnicornMessage <span class="hljs-keyword">message</span> = Unicorn.queryLastMessage();
</code></pre><p>在 V3.2 版本中增加了该接口的平台商家企业版本，需要传入商家ID，用于平台商家企业调用。</p>
<pre><code>/**
 * 获取和客服的最后一条聊天消息内容。
 * 可用于未读消息变化时，展示最后一条未读消息，或者展示客服的最后一条消息。
 *
 * @param shopId 商家ID
 * @<span class="hljs-keyword">return</span> 最后一条消息
 */
UnicornMessage <span class="hljs-keyword">message</span> = POPManager.queryLastMessage(<span class="hljs-keyword">String</span> shopId);
</code></pre><h3 id="清除缓存文件">清除缓存文件</h3><p>在 V3.4 版本中七鱼 SDK 增加了接收文件功能，为了防止文件过多占用用户手机存储空间，我们增加了清除缓存文件接口</p>
<pre><code><span class="hljs-comment">/**
 * 清除文件缓存，将删除SDK接收过的所有文件。&lt;br&gt;
 * 建议在工作线程中执行该操作。
 */</span>
<span class="hljs-selector-tag">Unicorn</span><span class="hljs-selector-class">.clearCache</span>();
</code></pre><h2 id="定制界面">定制界面</h2><h3 id="客服窗口UI自定义">客服窗口UI自定义</h3><p>为了咨询客服窗口的界面风格能与集成七鱼 SDK 的 APP 能够整体统一，七鱼 SDK 提供了简洁的 UI 自定义配置选项。</p>
<p>配置选项接口名为 UICustomization，配置参数放在 <code>YSFOptions</code> 的 <code>uiCustomization</code> 变量中，开发者可在初始化 SDK 或者在运行时任意时候修改配置，当需要与 SDK 提供的默认界面不一样表现的地方，就修改对应的项，否则不赋值即可，界面会保留默认表现。修改各设置项后，都需要等到下次进入会话界面才会看到相应的更改。</p>
<p>各配置项说明如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">参数说明</th>
<th style="text-align:left">取值说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">msgBackgroundUri</td>
<td style="text-align:left">String</td>
<td style="text-align:left">客服消息窗口背景图片设置</td>
<td style="text-align:left">uri（支持格式见表后）</td>
</tr>
<tr>
<td style="text-align:left">msgBackgroundColor</td>
<td style="text-align:left">int</td>
<td style="text-align:left">客服消息窗口颜色。如果同时设置 uri 和颜色，优先使用 uri</td>
<td style="text-align:left">32 位颜色值</td>
</tr>
<tr>
<td style="text-align:left">msgListViewDividerHeight</td>
<td style="text-align:left">int</td>
<td style="text-align:left">消息列表消息项间距</td>
<td style="text-align:left">单位为 pixel</td>
</tr>
<tr>
<td style="text-align:left">hideLeftAvatar</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">是否隐藏左侧(客服消息)头像</td>
<td style="text-align:left">默认为 false，不隐藏</td>
</tr>
<tr>
<td style="text-align:left">hideRightAvatar</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">是否隐藏右侧(访客消息)头像</td>
<td style="text-align:left">默认为 false，不隐藏</td>
</tr>
<tr>
<td style="text-align:left">avatarShape</td>
<td style="text-align:left">int</td>
<td style="text-align:left">头像形状风格</td>
<td style="text-align:left">0为圆形头像，1为方形头像</td>
</tr>
<tr>
<td style="text-align:left">leftAvatar</td>
<td style="text-align:left">String</td>
<td style="text-align:left">左侧 （客服消息）头像图片 uri</td>
<td style="text-align:left">uri（支持格式见表后）</td>
</tr>
<tr>
<td style="text-align:left">rightAvatar</td>
<td style="text-align:left">String</td>
<td style="text-align:left">右侧 （访客消息）头像图片 uri</td>
<td style="text-align:left">uri（支持格式见表后）</td>
</tr>
<tr>
<td style="text-align:left">tipsTextColor</td>
<td style="text-align:left">int</td>
<td style="text-align:left">提示类消息的字体颜色（包括分配客服消息，消息时间标签等）</td>
<td style="text-align:left">32 位颜色值</td>
</tr>
<tr>
<td style="text-align:left">tipsTextSize</td>
<td style="text-align:left">float</td>
<td style="text-align:left">提示类消息的字体大小（包括分配客服消息，消息时间标签等）</td>
<td style="text-align:left">单位为 sp</td>
</tr>
<tr>
<td style="text-align:left">msgItemBackgroundLeft</td>
<td style="text-align:left">int</td>
<td style="text-align:left">左边消息项背景, 最好是 selector，同时影响文本和语音消息。</td>
<td style="text-align:left">drawable resId</td>
</tr>
<tr>
<td style="text-align:left">msgItemBackgroundRight</td>
<td style="text-align:left">int</td>
<td style="text-align:left">右边消息项背景, 最好是 selector，同时影响文本和语音消息。</td>
<td style="text-align:left">drawable resId</td>
</tr>
<tr>
<td style="text-align:left">audioMsgAnimationLeft</td>
<td style="text-align:left">int</td>
<td style="text-align:left">左侧语音消息播放时候的动画 animation-list,没有播放时显示最后一帧</td>
<td style="text-align:left">drawable resId</td>
</tr>
<tr>
<td style="text-align:left">audioMsgAnimationRight</td>
<td style="text-align:left">int</td>
<td style="text-align:left">右侧语音消息播放时候的动画 animation-list,没有播放时显示最后一帧</td>
<td style="text-align:left">drawable resId</td>
</tr>
<tr>
<td style="text-align:left">textMsgColorLeft</td>
<td style="text-align:left">int</td>
<td style="text-align:left">左侧文本消息颜色</td>
<td style="text-align:left">32 位颜色值</td>
</tr>
<tr>
<td style="text-align:left">hyperLinkColorLeft</td>
<td style="text-align:left">int</td>
<td style="text-align:left">左侧文本消息中超链接的颜色</td>
<td style="text-align:left">32 位颜色值</td>
</tr>
<tr>
<td style="text-align:left">textMsgColorRight</td>
<td style="text-align:left">int</td>
<td style="text-align:left">右侧文本消息颜色</td>
<td style="text-align:left">32 位颜色值</td>
</tr>
<tr>
<td style="text-align:left">hyperLinkColorRight</td>
<td style="text-align:left">int</td>
<td style="text-align:left">右侧文本消息中超链接的颜色</td>
<td style="text-align:left">32 位颜色值</td>
</tr>
<tr>
<td style="text-align:left">textMsgSize</td>
<td style="text-align:left">float</td>
<td style="text-align:left">文本消息字体大小</td>
<td style="text-align:left">单位为sp</td>
</tr>
<tr>
<td style="text-align:left">inputTextColor</td>
<td style="text-align:left">int</td>
<td style="text-align:left">底部消息输入框的字体颜色</td>
<td style="text-align:left">32 位颜色值</td>
</tr>
<tr>
<td style="text-align:left">inputTextSize</td>
<td style="text-align:left">float</td>
<td style="text-align:left">底部消息输入框的字体大小</td>
<td style="text-align:left">单位为sp</td>
</tr>
<tr>
<td style="text-align:left">topTipBarBackgroundColor</td>
<td style="text-align:left">int</td>
<td style="text-align:left">顶部提示栏(没有客服，排队状态等)背景色</td>
<td style="text-align:left">32 位颜色值</td>
</tr>
<tr>
<td style="text-align:left">topTipBarTextColor</td>
<td style="text-align:left">int</td>
<td style="text-align:left">顶部提示栏文字颜色</td>
<td style="text-align:left">32 位颜色值</td>
</tr>
<tr>
<td style="text-align:left">topTipBarTextSize</td>
<td style="text-align:left">float</td>
<td style="text-align:left">顶部提示栏文字大小</td>
<td style="text-align:left">单位为 sp</td>
</tr>
<tr>
<td style="text-align:left">titleBackgroundResId</td>
<td style="text-align:left">int</td>
<td style="text-align:left">标题栏背景图</td>
<td style="text-align:left">drawable resId</td>
</tr>
<tr>
<td style="text-align:left">titleBackgroundColor</td>
<td style="text-align:left">int</td>
<td style="text-align:left">标题栏背景颜色，如果同时设置 drawable 和颜色，优先使用 drawable</td>
<td style="text-align:left">32 位颜色值</td>
</tr>
<tr>
<td style="text-align:left">titleBarStyle</td>
<td style="text-align:left">int</td>
<td style="text-align:left">标题栏风格，影响标题和标题栏上按钮的颜色</td>
<td style="text-align:left">目前支持： 0浅色系，1深色系</td>
</tr>
<tr>
<td style="text-align:left">titleCenter</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">标题居中</td>
<td style="text-align:left">如果为 true ，居中，否则（默认）居左</td>
</tr>
<tr>
<td style="text-align:left">buttonBackgroundColorList</td>
<td style="text-align:left">int</td>
<td style="text-align:left">发送，选择，预览等按钮的颜色</td>
<td style="text-align:left">ColorStateList，可参考 SDK 的 ysf_button_color_state_list</td>
</tr>
<tr>
<td style="text-align:left">buttonTextColor</td>
<td style="text-align:left">int</td>
<td style="text-align:left">发送，选择，预览等按钮的文字颜色</td>
<td style="text-align:left">32 位颜色值</td>
</tr>
<tr>
<td style="text-align:left">hideAudio</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">是否隐藏语音输入栏</td>
<td style="text-align:left">默认为 false，不隐藏</td>
</tr>
<tr>
<td style="text-align:left">hideAudioWithRobot</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">在机器人聊天界面是否隐藏输入栏</td>
<td style="text-align:left">默认为false，不隐藏。给机器人发送语音后，会先转成文字消息，再发送给机器人</td>
</tr>
<tr>
<td style="text-align:left">hideEmoji</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">是否隐藏表情输入栏</td>
<td style="text-align:left">默认为 false，不隐藏</td>
</tr>
<tr>
<td style="text-align:left">screenOrientation</td>
<td style="text-align:left">int</td>
<td style="text-align:left">屏幕旋转角度</td>
<td style="text-align:left">0 为仅竖屏显示，1为仅横屏显示，2为根据重力感应切换</td>
</tr>
<tr>
<td style="text-align:left">hideKeyboardOnEnterConsult</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">在进入聊天界面时是否隐藏输入键盘</td>
<td style="text-align:left">默认为 false，进入时就自动弹出键盘</td>
</tr>
</tbody>
</table>
<blockquote>
<p>图片 uri 支持的格式由开发者根据自己使用的图片加载框架定义。但必须要支持 file://， http:// 和 https:// 这3种。</p>
</blockquote>
<h3 id="其他界面">其他界面</h3><p>SDK 的所有资源文件名均以 nim 或者 ysf 作为前缀，colors 和 strings 中的常量也以 nim 或 ysf 为前缀，以避免污染开发者的资源名字空间。</p>
<p>聊天界面的根 layout 文件为 ysf_message_fragment.xml, 通过修改该文件，以及其引用的各子 layout 文件，可以修改聊天界面的框架布局。通过修改其中引用的素材资源，可以修改界面的上各图标，字体，背景等。</p>
<p>SDK 自带的会话界面为 ServiceMessageActivity, 其 theme 为 ysf_window_theme, 如果需要修改标题栏样式，可以修改该 style。 该 style 位于 ysf_styles.xml 中。</p>
<p>如果修改 SDK 中的资源文件，以后升级 SDK 时要注意重新替换，以免又回到默认界面上。</p>
<p>SDK 还提供了以 fragment 嵌入的方式集成会话界面，开发者可以更灵活的使用 SDK。示例代码如下：</p>
<pre><code><span class="hljs-type">String</span> title = <span class="hljs-string">"聊天窗口的标题"</span>;
<span class="hljs-comment">// 访客来源信息</span>
<span class="hljs-type">ConsultSource</span> source = <span class="hljs-function"><span class="hljs-keyword">new</span> <span class="hljs-title">ConsultSource</span>(sourceUrl, sourceTitle, "custom information string");
/**
 * 构造一个 <span class="hljs-title">ViewGroup</span>，用于放置<span class="hljs-title">sdk</span>的评价和人工客服按钮。
 * 该控件推荐放在标题栏右边。可以用以下两种方式：
 * 1. 将 <span class="hljs-title">container</span> 放到 <span class="hljs-title">layout</span> 文件中
 * <span class="hljs-title">LinearLayout</span> <span class="hljs-title">sdkIconContainer</span> = (<span class="hljs-type">LinearLayout</span>)<span class="hljs-title">findViewById</span>(<span class="hljs-type">R</span>.id.xxx);
 * 2. 动态构建，动态添加
 * <span class="hljs-title">LinearLayout</span> <span class="hljs-title">sdkIconContainer</span> = <span class="hljs-title">new</span> <span class="hljs-title">LinearLayout</span>(this);
 * <span class="hljs-title">sdkIconContainer</span>.<span class="hljs-title">setOrientation</span>(<span class="hljs-type">LinearLayout</span>.<span class="hljs-type">HORIZONTAL</span>);
 * 构造好后，还需要将 <span class="hljs-title">ViewGroup</span> 添加到你的 <span class="hljs-title">Activity</span> 中
 */
<span class="hljs-title">ServiceMessageFragment</span> <span class="hljs-title">fragment</span> = <span class="hljs-title">Unicorn</span>.<span class="hljs-title">newServiceFragment</span>(title, source, sdkIconContainer);
<span class="hljs-title">FragmentManager</span> <span class="hljs-title">fm</span> = <span class="hljs-title">getSupportFragmentManager</span>();
<span class="hljs-title">FragmentTransaction</span> <span class="hljs-title">transaction</span> = <span class="hljs-title">fm</span>.<span class="hljs-title">beginTransaction</span>();
<span class="hljs-comment">// 将 fragment 放到对应的 containerId 中。containerId 为 ViewGroup 的 resId</span>
<span class="hljs-title">transaction</span>.<span class="hljs-title">replace</span>(containerId, fragment);
<span class="hljs-title">try</span> {
    <span class="hljs-title">transaction</span>.<span class="hljs-title">commitAllowingStateLoss</span>();
} <span class="hljs-title">catch</span> (<span class="hljs-type">Exception</span> e) {
}</span>
</code></pre><h3 id="人工客服快捷入口">人工客服快捷入口</h3><p>在 3.13 版本中，七鱼 SDK 新增人工客服模式下的快捷入口，可用于用户选择并发送订单给客服。</p>
<p>快捷入口位于输入框上方，仅在人工客服和留言状态下显示。如果需要展示快捷入口，需要按照以下方法配置：</p>
<ol>
<li>为 <code>ConsultSource</code> 中的 <code>quickEntryList</code> 赋值，添加快捷入口</li>
</ol>
<pre><code>ConsultSource <span class="hljs-keyword">source</span> = <span class="hljs-keyword">new</span> ConsultSource(uri, title, custom);
...
<span class="hljs-keyword">source</span>.quickEntryList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
<span class="hljs-keyword">source</span>.quickEntryList.add(<span class="hljs-keyword">new</span> QuickEntry(<span class="hljs-number">0</span>, <span class="hljs-string">"查订单"</span>, iconUrl));
<span class="hljs-keyword">source</span>.quickEntryList.add(<span class="hljs-keyword">new</span> QuickEntry(<span class="hljs-number">1</span>, <span class="hljs-string">"查物流"</span>, iconUrl));
</code></pre><ol>
<li>为 <code>YSFOptions</code> 中的 <code>quickEntryListener</code> 赋值，用于监听快捷入口点击</li>
</ol>
<pre><code>YSFOptions options = <span class="hljs-keyword">new</span> YSFOptions();
...
options.quickEntryListener = <span class="hljs-keyword">new</span> QuickEntry.Listener() {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(Context context, String shopId, QuickEntry quickEntry)</span> </span>{
        ToastUtils.show(<span class="hljs-string">"点击快捷入口"</span> + quickEntry.getId());
        <span class="hljs-keyword">if</span> (quickEntry.getId() == <span class="hljs-number">0</span>) {
            <span class="hljs-comment">// 这里可根据 QuickEntry 做出相应的相应，如打开订单选择窗口</span>
        }
    }
};
</code></pre><p>如果需要在用户选择订单后将商品信息发送给客服，需要调用以下接口</p>
<pre><code><span class="hljs-comment">// 普通企业</span>
<span class="hljs-selector-tag">Unicorn</span><span class="hljs-selector-class">.sendProductMessage</span>(ProductDetail);

<span class="hljs-comment">// 平台企业</span>
<span class="hljs-selector-tag">POPManager</span><span class="hljs-selector-class">.sendProductMessage</span>(shopId, ProductDetail);
</code></pre><h2 id="关联商户用户信息">关联商户用户信息</h2><h3 id="关联用户和资料">关联用户和资料</h3><p>七鱼 SDK 允许 APP 的用户以匿名方式向客户咨询，但如果 APP 希望客服知道咨询的用户的身份信息，可以通过 SDK 提供的 <code>setUserInfo</code> 接口告诉给客服。 该接口包含两个功能：</p>
<ol>
<li>关联用户账户。调用过该接口后，客服即可知道当前用户是谁，并可以调看该用户之前发生过的访问记录。通过该接口，SDK还会把 APP 端相同用户 ID 的咨询记录整合在一起。如果调用 <code>setUserInfo</code> 接口前是匿名状态，那么匿名状态下的聊天记录也会被整合到新设置的这个用户下面。</li>
<li>提供用户的详细资料。通过设置参数 <code>YSFUserInfo</code> 的 data 字段， APP 能把用户的详细信息告诉给客服，这些信息会显示在客服会话窗口的用户信息栏中。该字段具有很强的可扩展性，具体请见本节后面的描述。</li>
</ol>
<p>为了区分不同的 APP 用户，当 APP 端用户注销后，需要先调用 <code>Unicorn.logout()</code>，告诉 SDK，SDK 此时会关闭前一个用户的聊天记录，并重新分配一个新的聊天账号，以和之前的用户区分。</p>
<p><strong>注意，该接口不允许直接从一个账号切换到另外一个账号。</strong></p>
<p>为了方便开发者调用，这个接口没有设置回调接口，开发者也无需在用户资料发生变更后就调用该接口。开发者可在每次打开客服窗口时调用该函数，设置访客资料。SDK会缓存上次设置的资料，只有当资料发生改动时SDK才会上传，以节省流量。</p>
<p>访客信息为一个 json 数组，该数组中的 item 目前可包含以下字段：</p>
<ul>
<li>key: 数据项的名称，用于区别不同的数据。</li>
<li>index: 用于排序，显示数据时数据项按index值升序排列；不设定index的数据项将排在后面；index相同或未设定的数据项将按照其在 JSON 中出现的顺序排列。</li>
<li>label: 该项数据显示的名称。</li>
<li>value: 该数据显示的值，类型不做限定，根据实际需要进行设定。</li>
<li>href: 超链接地址。若指定该值，则该项数据将显示为超链接样式，点击后跳转到其值所指定的 URL 地址。</li>
<li>hidden: 是否隐藏该item。目前仅对mobile和email有效。</li>
</ul>
<p>现在，以下4个key由七鱼使用，他们的排序和标签名是固定的，不能指定index和label。</p>
<ul>
<li>real_name: 用户姓名。</li>
<li>mobile_phone：用户手机号，可以隐藏。</li>
<li>email：用户的邮箱账号，可以隐藏。</li>
<li>avatar: 用户的头像，可以在客服端显示。访客端的用户头像不会使用该字段。</li>
</ul>
<p>设置访客信息的示例如下：</p>
<pre><code>YSFUserInfo userInfo = <span class="hljs-keyword">new</span> YSFUserInfo();
<span class="hljs-comment">// APP 的用户 ID</span>
userInfo.userId = <span class="hljs-string">"uid"</span>;
<span class="hljs-comment">// 当且仅当开发者在管理后台开启了 authToken 校验功能时，该字段才有效</span>
userInfo.authToken = <span class="hljs-string">"auth-token-from-user-server"</span>;
<span class="hljs-comment">// CRM 扩展字段</span>
userInfo.data=<span class="hljs-string">"[
    {"</span>key<span class="hljs-string">":"</span>real_name<span class="hljs-string">", "</span>value<span class="hljs-string">":"</span>土豪<span class="hljs-string">"},
    {"</span>key<span class="hljs-string">":"</span>mobile_phone<span class="hljs-string">", "</span>hidden<span class="hljs-string">":true},
    {"</span>key<span class="hljs-string">":"</span>email<span class="hljs-string">", "</span>value<span class="hljs-string">":"</span><span class="hljs-number">13800000000</span>@<span class="hljs-number">163.</span>com<span class="hljs-string">"},
    {"</span>key<span class="hljs-string">":"</span>avata<span class="hljs-string">r", "</span>value<span class="hljs-string">": "</span>https:<span class="hljs-comment">//qiyukf.com/def_avatar.png"},</span>
    {<span class="hljs-string">"index"</span>:<span class="hljs-number">0</span>, <span class="hljs-string">"key"</span>:<span class="hljs-string">"account"</span>, <span class="hljs-string">"label"</span>:<span class="hljs-string">"账号"</span>, <span class="hljs-string">"value"</span>:<span class="hljs-string">"zhangsan"</span> , <span class="hljs-string">"href"</span>:<span class="hljs-string">"http://example.domain/user/zhangsan"</span>},
    {<span class="hljs-string">"index"</span>:<span class="hljs-number">1</span>, <span class="hljs-string">"key"</span>:<span class="hljs-string">"sex"</span>, <span class="hljs-string">"label"</span>:<span class="hljs-string">"性别"</span>, <span class="hljs-string">"value"</span>:<span class="hljs-string">"先生"</span>},
    {<span class="hljs-string">"index"</span>:<span class="hljs-number">5</span>, <span class="hljs-string">"key"</span>:<span class="hljs-string">"reg_date"</span>, <span class="hljs-string">"label"</span>:<span class="hljs-string">"注册日期"</span>, <span class="hljs-string">"value"</span>:<span class="hljs-string">"2015-11-16"</span>},
    {<span class="hljs-string">"index"</span>:<span class="hljs-number">6</span>, <span class="hljs-string">"key"</span>:<span class="hljs-string">"last_login"</span>, <span class="hljs-string">"label"</span>:<span class="hljs-string">"上次登录时间"</span>, <span class="hljs-string">"value"</span>:<span class="hljs-string">"2015-12-22 15:38:54"</span>}
]<span class="hljs-string">";
Unicorn.setUserInfo(userInfo);</span>
</code></pre><h3 id="注销">注销</h3><p>如前所述，当关联的用户从 APP 注销后，也应当调用 SDK 的注销接口 <code>Unicorn.logout()</code>。这样，注销之后，客服再给前面用户发送消息，将进入留言，等到该用户下次再在同一台设备上登录后，能够再看到。如果 APP 的用户注销后，不调用七鱼的 logout 接口，七鱼不知道用户已经变更，那么客服如果给前面一个用户发起会话，发送消息，当前设备将仍旧能够收到消息，造成混乱。</p>
<p><code>Unicorn.logout()</code> 接口等效于 <code>Unicorn.setUserInfo(null)</code>。</p>
<p>注意：目前不支持跨设备的消息漫游，在其他设备上通过 <code>setUserInfo(YSFUserInfo)</code> 设置相同的用户, 这个设备上不能收到留言。</p>
<h2 id="自定义客服分配">自定义客服分配</h2><p>在打开客服咨询窗口或者构造 <code>ServiceMessageFragment</code> 时，接口中有一个参数是 <code>ConsultSource</code>，通过该参数，我们可以对分配客服的流程做一些自定义操作。</p>
<h3 id="指定客服（组）">指定客服（组）</h3><p>在 2.0 之前的版本中，请求客服时会根据企业在管理后台上对 APP 客服分配的设置，来决定首先接入机器人还是人工客服，如果管理后台开启了机器人，则首先会接入机器人。如果管理后台也允许接入人工客服，那么用户可以通过回复 &#39;RG&#39; 或者 &#39;人工客服&#39; 一类的关键字切换到人工客服，界面上也能展现一个人工客服的入口，用户点击此入口，也能接入人工客服。</p>
<p>在 2.0 版本中，七鱼加入了访客分配的逻辑。如果APP端开启了访客分配，那么当切换到人工客服时，会首先给出一个客服分组选择的入口，用户可以自主选择某个客服或者客服分组咨询。</p>
<p>在 2.2 版本中，SDK 在 <code>ConsultSource</code> 增加了指定客服或者客服组的参数，开发者可以在访客进入咨询界面前就指定好要为其服务的客服，例如从订单页面打开咨询界面时为其指定售后客服，在商品页面打开时，为其指定售前客服。在 <code>ConsultSource</code> 中，<code>staffId</code> 为客服 ID，<code>groupId</code> 为客服组 ID，其值可以在管理后台设置页面的「访客分配」页面中找到。如果这两个参数都没有设置，则按照2.0版本的逻辑分配客服，如果指定了其中一个，则只会分配指定的客服或者在指定的客服分组中分配，如果指定的客服不在线，或者指定的客服分组中没有客服在线，则会提示用户客服不在线。如果同时指定 <code>staffId</code> 和 <code>groupId</code>，以 <code>staffId</code> 为准，忽略 <code>groupId</code>。</p>
<p>在 3.1 版本中，SDK 又在 <code>ConsultSource</code> 中增加了 robotFirst 参数， 如果指定了 groupId 或者 staffId 时，该参数有效。如果 robotFirst 为 <code>true</code>，则会先由机器人接待，如果之后如果用户转人工服务，再分配给上面指定的groupId 或者 staffId。</p>
<p>在 3.1 版本中，为了提高机器人的效率，在 <code>ConsultSource</code> 中还增加了 faqGroupId 参数。 faq 由客服人员在管理后台配置。如果指定了此参数，且请求客服为机器人客服，则会下发该 ID 对应的热门问题列表。</p>
<h3 id="指定机器人">指定机器人</h3><p>在 3.12 版本中，为了满足企业不同业务，在 <code>ConsultSource</code> 中增加了 robotId 参数，用于指定特定的机器人客服。机器人 ID 可以在管理后台 - 设置 - App接入 中查看。</p>
<h3 id="汇报商品信息">汇报商品信息</h3><p>在打开咨询窗口时，还可以带上用户当前正在浏览的商品或订单信息。在 <code>ConsultSource</code> 中，设置字段为 <code>productDetail</code>，其类型为 <code>ProductDetail</code>。各字段通过 <code>ProductDetail.Builder</code> 设置，可以设置的信息有：</p>
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">意义</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">title</td>
<td style="text-align:left">商品标题</td>
<td style="text-align:left">长度限制为 100 字符，超过自动截断。</td>
</tr>
<tr>
<td style="text-align:left">desc</td>
<td style="text-align:left">商品详细描述信息。</td>
<td style="text-align:left">长度限制为 300 字符，超过自动截断。</td>
</tr>
<tr>
<td style="text-align:left">note</td>
<td style="text-align:left">商品备注信息（价格，套餐等）</td>
<td style="text-align:left">长度限制为 100 字符，超过自动截断。</td>
</tr>
<tr>
<td style="text-align:left">picture</td>
<td style="text-align:left">缩略图图片的 url。</td>
<td style="text-align:left">该 url 需要没有跨域访问限制，否则在客服端会无法显示。<br> 长度限制为 1000 字符， 超长不会自动截断，但会发送失败。</td>
</tr>
<tr>
<td style="text-align:left">url</td>
<td style="text-align:left">商品信息详情页 url。</td>
<td style="text-align:left">长度限制为 1000 字符，超长不会自动截断，但会发送失败。</td>
</tr>
<tr>
<td style="text-align:left">show</td>
<td style="text-align:left">是否在访客端显示商品消息。</td>
<td style="text-align:left">默认为0，即客服能看到此消息，但访客看不到，也不知道该消息已发送给客服。</td>
</tr>
<tr>
<td style="text-align:left">alwaysSend</td>
<td style="text-align:left">在会话开始后，仍可以发送该商品字段</td>
<td style="text-align:left">默认为 false，不发送。</td>
</tr>
</tbody>
</table>
<p>在3.1.0版本之前，商品信息只有在连上客服时发送一次，此后如果没有重新连接客服，无论商品信息是否改变，都不会再继续发送了。从3.1.0版本开始，开发者可以通过 <code>alwaysSend</code> 字段控制是否需要在中途发送新的商品信息。注意，如果上一次发送的商品链接和这一次的相同，后面一次的不会再发送给客服。</p>
<h3 id="设置用户VIP等级">设置用户VIP等级</h3><p>在 3.5 版本中，七鱼客服增加了设置用户 VIP 等级的功能，便于区分用户等级，允许 VIP 用户优先进线或为 VIP 用户指定专线客服，提升用户体验。</p>
<p>使用该功能需要在七鱼管理系统 -&gt; 设置 -&gt; VIP 客户设置页面打开 VIP 开关，否则设置将不会生效。</p>
<p>设置用户 VIP 等级需要为 <code>ConsultSource</code> 中的 <code>vipLevel</code> 字段赋值：</p>
<ul>
<li>如果为 0，为普通用户；</li>
<li>如果为 1-10，为用户 VIP 等级 1-10 级；</li>
<li>如果为 11，为通用 VIP 用户，即不显示用户等级。</li>
</ul>
<h3 id="控制会话过程">控制会话过程</h3><p>从 3.5.5 版本开始，SDK 增加了开发者对于会话过程控制的力度，允许用户主动结束会话和主动退出排队。</p>
<p>控制会话过程的设置类是 <code>SessionLifeCycleOptions</code>，可以在开始会话前设置给 <code>ConsultSource</code> 的 <code>sessionLifeCycleOptions</code> 字段。示例代码如下：</p>
<pre><code>ConsultSource <span class="hljs-keyword">source</span> = <span class="hljs-keyword">new</span> ConsultSource(<span class="hljs-keyword">null</span>, <span class="hljs-string">"自定义入口"</span>, <span class="hljs-keyword">null</span>);
SessionLifeCycleOptions lifeCycleOptions = <span class="hljs-keyword">new</span> SessionLifeCycleOptions();
lifeCycleOptions.setCanCloseSession(<span class="hljs-keyword">boolean</span>)
        .setCanQuitQueue(<span class="hljs-keyword">boolean</span>)
        .setQuitQueuePrompt(String);
<span class="hljs-keyword">source</span>.sessionLifeCycleOptions = lifeCycleOptions;
Unicorn.openServiceActivity(context, title, <span class="hljs-keyword">source</span>);
</code></pre><p>如果使用 fragment 集成，则还需要对<code>SessionLifeCycleOptions</code>的<code>sessionLifeCycleListener</code>字段赋值，配置<code>会话界面退出监听器</code>，详见<code>SessionLifeCycleListener</code>。</p>
<h2 id="图片加载">图片加载</h2><p>图片加载基本上每个 APP 都会用到，各个 APP 也都会有自己的实现或者依赖的第三方库。为了避免 SDK 引入第三方图片库后，与 APP 自身依赖的图片库冲突，或者与 APP 用了不同的库造成浪费，从 2.0.0 版本开始，七鱼 SDK 需要由 APP 实现一个图片加载接口，并传给 YSFOptions。 下面是两个常用的第三方图片加载库的接口实现示例，开发者可以直接使用。</p>
<p>图片加载参数中的 uri 格式，只要是 APP 选用的图片框架支持即可。但请注意，必须支持本地文件 uri （file://）和 网络文件 uri (http:// 或者 https://) 这两种格式。</p>
<h3 id="UniversalImageLoader实现">UniversalImageLoader实现</h3><p>该实现依赖 universal-image-loader 库，需要在工程的 build.gradle 文件中添加依赖：</p>
<pre><code><span class="hljs-keyword">compile</span> <span class="hljs-string">'com.nostra13.universalimageloader:universal-image-loader:1.9.5'</span>
</code></pre><p>如果使用的 IDE 是 Eclipse，则需要在 libs 中添加 universal-image-loader 的 jar 包。</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> class UILImageLoader implements UnicornImageLoader {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> TAG = <span class="hljs-string">"UILImageLoader"</span>;

    @Override
    <span class="hljs-keyword">public</span> Bitmap loadImageSync(<span class="hljs-keyword">String</span> uri, <span class="hljs-built_in">int</span> <span class="hljs-built_in">width</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">height</span>) {
        DisplayImageOptions options = <span class="hljs-keyword">new</span> DisplayImageOptions.Builder()
                .cacheInMemory(<span class="hljs-keyword">true</span>)
                .cacheOnDisk(<span class="hljs-keyword">false</span>)
                .bitmapConfig(Bitmap.Config.RGB_565)
                .build();

        <span class="hljs-comment">// check cache</span>
        <span class="hljs-built_in">boolean</span> cached = <span class="hljs-keyword">true</span>;
        ImageDownloader.Scheme scheme = ImageDownloader.Scheme.ofUri(uri);
        <span class="hljs-keyword">if</span> (scheme == ImageDownloader.Scheme.HTTP
                || scheme == ImageDownloader.Scheme.HTTPS
                || scheme == ImageDownloader.Scheme.UNKNOWN) {
            <span class="hljs-comment">// non local resource</span>
            cached = MemoryCacheUtils.findCachedBitmapsForImageUri(uri, ImageLoader.getInstance().getMemoryCache()).<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>
                    || DiskCacheUtils.findInCache(uri, ImageLoader.getInstance().getDiskCache()) != <span class="hljs-keyword">null</span>;
        }

        <span class="hljs-keyword">if</span> (cached) {
            ImageSize imageSize = (<span class="hljs-built_in">width</span> &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">height</span> &gt; <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> ImageSize(<span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>) : <span class="hljs-keyword">null</span>;
            Bitmap bitmap = ImageLoader.getInstance().loadImageSync(uri, imageSize, options);
            <span class="hljs-keyword">if</span> (bitmap == <span class="hljs-keyword">null</span>) {
                Log.e(TAG, <span class="hljs-string">"load cached image failed, uri ="</span> + uri);
            }
            <span class="hljs-keyword">return</span> bitmap;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    @Override
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">loadImage</span>(<span class="hljs-keyword">String</span> uri, <span class="hljs-built_in">int</span> <span class="hljs-built_in">width</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">height</span>, <span class="hljs-keyword">final</span> ImageLoaderListener listener) {
        DisplayImageOptions options = <span class="hljs-keyword">new</span> DisplayImageOptions.Builder()
                .cacheInMemory(<span class="hljs-keyword">true</span>)
                .cacheOnDisk(<span class="hljs-keyword">false</span>)
                .bitmapConfig(Bitmap.Config.RGB_565)
                .build();
        ImageSize imageSize = (<span class="hljs-built_in">width</span> &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">height</span> &gt; <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> ImageSize(<span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>) : <span class="hljs-keyword">null</span>;

        ImageLoader.getInstance().<span class="hljs-built_in">loadImage</span>(uri, imageSize, options, <span class="hljs-keyword">new</span> SimpleImageLoadingListener() {
            @Override
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onLoadingComplete(<span class="hljs-keyword">String</span> imageUri, View view, Bitmap loadedImage) {
                <span class="hljs-keyword">super</span>.onLoadingComplete(imageUri, view, loadedImage);
                <span class="hljs-keyword">if</span> (listener != <span class="hljs-keyword">null</span>) {
                    listener.onLoadComplete(loadedImage);
                }
            }

            @Override
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onLoadingFailed(<span class="hljs-keyword">String</span> imageUri, View view, FailReason failReason) {
                <span class="hljs-keyword">super</span>.onLoadingFailed(imageUri, view, failReason);
                <span class="hljs-keyword">if</span> (listener != <span class="hljs-keyword">null</span>) {
                    listener.onLoadFailed(failReason.getCause());
                }
            }
        });
    }
}
</code></pre>
<h3 id="fresco实现">fresco实现</h3><p>fresco 库本身提供了一整套图片缓存和加载的功能，由于 SDK 中部分 ImageView 需要做自定义的绘制，因此只会用到其下载，解码和缓存的逻辑。</p>
<p>该实现依赖 fresco 库，需要在工程的 build.gradle 文件中添加依赖：</p>
<pre><code><span class="hljs-keyword">compile</span> <span class="hljs-string">'com.facebook.fresco:fresco:0.9.0'</span>
</code></pre><p>如果使用的 IDE 是 Eclipse，则需要在 libs 中添加 fresco 的 jar 包。</p>
<pre><code class="lang-java">public class FrescoImageLoader implements UnicornImageLoader {
    private <span class="hljs-built_in">Context</span> <span class="hljs-built_in">context</span><span class="hljs-comment">;</span>

    public FrescoImageLoader(<span class="hljs-built_in">Context</span> <span class="hljs-built_in">context</span>) {
        this.context = <span class="hljs-built_in">context</span>.getApplicationContext()<span class="hljs-comment">;</span>
    }

    @Override
    public <span class="hljs-keyword">Bitmap </span>loadImageSync(String uri, int width, int height) {
        <span class="hljs-keyword">Bitmap </span>resultBitmap = null<span class="hljs-comment">;</span>
        ImagePipeline imagePipeline = Fresco.getImagePipeline()<span class="hljs-comment">;</span>
        <span class="hljs-keyword">boolean </span>inMemoryCache = imagePipeline.isInBitmapMemoryCache(Uri.parse(uri))<span class="hljs-comment">;</span>
        if (inMemoryCache) {
            ImageRequestBuilder <span class="hljs-keyword">builder </span>= ImageRequestBuilder.newBuilderWithSource(Uri.parse(uri))<span class="hljs-comment">;</span>
            if (width &gt; <span class="hljs-number">0</span> &amp;&amp; height &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">builder.setResizeOptions(new </span>ResizeOptions(width, height))<span class="hljs-comment">;</span>
            }
            ImageRequest imageRequest = <span class="hljs-keyword">builder.build();
</span>            DataSource&lt;<span class="hljs-keyword">CloseableReference&lt;CloseableImage&gt;&gt; </span>dataSource =
                    imagePipeline.fetchImageFromBitmapCache(imageRequest, <span class="hljs-built_in">context</span>)<span class="hljs-comment">;</span>
            <span class="hljs-keyword">CloseableReference&lt;CloseableImage&gt; </span>imageReference = dataSource.getResult()<span class="hljs-comment">;</span>
            try {
                if (imageReference != null) {
                    <span class="hljs-keyword">CloseableImage </span><span class="hljs-keyword">closeableImage </span>= imageReference.get()<span class="hljs-comment">;</span>
                    if (<span class="hljs-keyword">closeableImage </span>!= null &amp;&amp; <span class="hljs-keyword">closeableImage </span><span class="hljs-keyword">instanceof </span><span class="hljs-keyword">CloseableBitmap) </span>{
                        <span class="hljs-keyword">Bitmap </span>underlyingBitmap = ((<span class="hljs-keyword">CloseableBitmap) </span><span class="hljs-keyword">closeableImage).getUnderlyingBitmap();
</span>                        if (underlyingBitmap != null &amp;&amp; !underlyingBitmap.isRecycled()) {
                            resultBitmap = underlyingBitmap.copy(<span class="hljs-keyword">Bitmap.Config.RGB_565, </span>false)<span class="hljs-comment">;</span>
                        }
                    }
                }
            } finally {
                dataSource.<span class="hljs-keyword">close();
</span>                <span class="hljs-keyword">CloseableReference.closeSafely(imageReference);
</span>            }
        }
        return resultBitmap<span class="hljs-comment">;</span>
    }

    @Override
    public void loadImage(String uri, int width, int height, final ImageLoaderListener listener) {
        ImageRequestBuilder <span class="hljs-keyword">builder </span>= ImageRequestBuilder.newBuilderWithSource(Uri.parse(uri))<span class="hljs-comment">;</span>
        if (width &gt; <span class="hljs-number">0</span> &amp;&amp; height &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">builder.setResizeOptions(new </span>ResizeOptions(width, height))<span class="hljs-comment">;</span>
        }
        ImageRequest imageRequest = <span class="hljs-keyword">builder.build();
</span>
        ImagePipeline imagePipeline = Fresco.getImagePipeline()<span class="hljs-comment">;</span>
        DataSource&lt;<span class="hljs-keyword">CloseableReference&lt;CloseableImage&gt;&gt; </span>dataSource = imagePipeline.fetchDecodedImage(imageRequest, <span class="hljs-built_in">context</span>)<span class="hljs-comment">;</span>

        <span class="hljs-keyword">BaseBitmapDataSubscriber </span><span class="hljs-keyword">subscriber </span>= new <span class="hljs-keyword">BaseBitmapDataSubscriber() </span>{
            @Override
            public void onNewResultImpl(@Nullable <span class="hljs-keyword">Bitmap </span><span class="hljs-keyword">bitmap) </span>{
                if (listener != null) {
                    new AsyncTask&lt;<span class="hljs-keyword">Bitmap, </span>Void, <span class="hljs-keyword">Bitmap&gt;() </span>{
                        @Override
                        protected <span class="hljs-keyword">Bitmap </span>doInBackground(<span class="hljs-keyword">Bitmap... </span>params) {
                            <span class="hljs-keyword">Bitmap </span><span class="hljs-keyword">bitmap </span>= params[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span>
                            <span class="hljs-keyword">Bitmap </span>result = null<span class="hljs-comment">;</span>
                            if (<span class="hljs-keyword">bitmap </span>!= null &amp;&amp; !<span class="hljs-keyword">bitmap.isRecycled()) </span>{
                                result = <span class="hljs-keyword">bitmap.copy(Bitmap.Config.RGB_565, </span>false)<span class="hljs-comment">;</span>
                            }
                            return result<span class="hljs-comment">;</span>
                        }

                        @Override
                        protected void onPostExecute(<span class="hljs-keyword">Bitmap </span><span class="hljs-keyword">bitmap) </span>{
                            if (<span class="hljs-keyword">bitmap </span>!= null) {
                                listener.onLoadComplete(<span class="hljs-keyword">bitmap);
</span>                            } else {
                                listener.onLoadFailed(null)<span class="hljs-comment">;</span>
                            }
                        }
                    }.execute(<span class="hljs-keyword">bitmap);
</span>                }
            }

            @Override
            public void onFailureImpl(DataSource dataSource) {
                if (listener != null) {
                    listener.onLoadFailed(dataSource.getFailureCause())<span class="hljs-comment">;</span>
                }
            }
        }<span class="hljs-comment">;</span>

        dataSource.<span class="hljs-keyword">subscribe(subscriber, </span>UiThreadImmediateExecutorService.getInstance())<span class="hljs-comment">;</span>
    }
}
</code></pre>
<h3 id="Glide实现">Glide实现</h3><p>该实现依赖 Glide 库，需要在工程的 build.gradle 文件中添加依赖：</p>
<pre><code><span class="hljs-keyword">compile</span> <span class="hljs-string">'com.github.bumptech.glide:glide:3.7.0'</span>
</code></pre><p>如果使用的 IDE 是 Eclipse，则需要在 libs 中添加 Glide 的 jar 包。</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlideImageLoader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UnicornImageLoader</span> </span>{
    <span class="hljs-keyword">private</span> Context context;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GlideImageLoader</span><span class="hljs-params">(Context context)</span> </span>{
        <span class="hljs-keyword">this</span>.context = context.getApplicationContext();
    }

    <span class="hljs-meta">@Nullable</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Bitmap <span class="hljs-title">loadImageSync</span><span class="hljs-params">(String uri, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadImage</span><span class="hljs-params">(String uri, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">final</span> ImageLoaderListener listener)</span> </span>{
        Glide.with(context).load(uri).asBitmap().into(<span class="hljs-keyword">new</span> SimpleTarget&lt;Bitmap&gt;(width, height) {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResourceReady</span><span class="hljs-params">(Bitmap resource, GlideAnimation&lt;? <span class="hljs-keyword">super</span> Bitmap&gt; glideAnimation)</span> </span>{
                <span class="hljs-keyword">if</span> (listener != <span class="hljs-keyword">null</span>) {
                    listener.onLoadComplete(resource);
                }
            }

            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLoadFailed</span><span class="hljs-params">(Exception e, Drawable errorDrawable)</span> </span>{
                <span class="hljs-keyword">if</span> (listener != <span class="hljs-keyword">null</span>) {
                    listener.onLoadFailed(e);
                }
            }
        });
    }
}
</code></pre>
<h3 id="Picasso实现">Picasso实现</h3><p>该实现依赖 Picasso 库，需要在工程的 build.gradle 文件中添加依赖：</p>
<pre><code><span class="hljs-keyword">compile</span> <span class="hljs-string">'com.squareup.picasso:picasso:2.5.2'</span>
</code></pre><p>如果使用的 IDE 是 Eclipse，则需要在 libs 中添加 Picasso 的 jar 包。</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PicassoImageLoader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UnicornImageLoader</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors();
    <span class="hljs-keyword">private</span> Context context;
    <span class="hljs-keyword">private</span> ExecutorService threadPool;
    <span class="hljs-keyword">private</span> Handler uiHandler;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PicassoImageLoader</span><span class="hljs-params">(Context context)</span> </span>{
        <span class="hljs-keyword">this</span>.context = context.getApplicationContext();
        uiHandler = <span class="hljs-keyword">new</span> Handler(Looper.getMainLooper());
        threadPool = Executors.newFixedThreadPool(CPU_COUNT + <span class="hljs-number">1</span>);
    }

    <span class="hljs-meta">@Nullable</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Bitmap <span class="hljs-title">loadImageSync</span><span class="hljs-params">(String uri, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadImage</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String uri, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">final</span> ImageLoaderListener listener)</span> </span>{
        threadPool.execute(<span class="hljs-keyword">new</span> Runnable() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                RequestCreator requestCreator = Picasso
                        .with(context)
                        .load(uri)
                        .config(Bitmap.Config.RGB_565);
                <span class="hljs-keyword">if</span> (width &gt; <span class="hljs-number">0</span> &amp;&amp; height &gt; <span class="hljs-number">0</span>) {
                    requestCreator = requestCreator
                            .resize(width, height)
                            .centerCrop();
                }

                Bitmap bitmap = <span class="hljs-keyword">null</span>;
                <span class="hljs-keyword">try</span> {
                    bitmap = requestCreator.get();
                } <span class="hljs-keyword">catch</span> (IOException e) {
                    e.printStackTrace();
                }

                <span class="hljs-keyword">if</span> (listener == <span class="hljs-keyword">null</span>) {
                    <span class="hljs-keyword">return</span>;
                }

                <span class="hljs-keyword">if</span> (bitmap != <span class="hljs-keyword">null</span> &amp;&amp; !bitmap.isRecycled()) {
                    <span class="hljs-keyword">final</span> Bitmap finalBitmap = bitmap;
                    uiHandler.post(<span class="hljs-keyword">new</span> Runnable() {
                        <span class="hljs-meta">@Override</span>
                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                            listener.onLoadComplete(finalBitmap);
                        }
                    });
                } <span class="hljs-keyword">else</span> {
                    uiHandler.post(<span class="hljs-keyword">new</span> Runnable() {
                        <span class="hljs-meta">@Override</span>
                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                            listener.onLoadFailed(<span class="hljs-keyword">null</span>);
                        }
                    });
                }
            }
        });
    }
}
</code></pre>
<h2 id="省电策略">省电策略</h2><p>七鱼 SDK 作为用户端的 IM 工具，需要能够及时收到客服回复的消息。同时，就算用户没有主动咨询过客服，客服也可以主动发起会话，进行主动营销。因此，在 2.0 版本之前，SDK一旦初始化之后，会一直保持长连接，定时与服务器交换心跳。</p>
<p>但是，毕竟用户咨询以及客服主动营销都是不太常用的操作，为此保持一个长连接，性价比不高。同时，我们了解到，很多客户的 APP 本身就自带了推送模块，或者集成了第三方的推送 SDK，由此就存在了两条长连接，浪费了用户的电量和流量。因此，在2.0版本中，我们针对 SDK 的长连接策略做了更改，以优化在用户没有发起咨询时的电量消耗。如果开发者需要开启省电特性，需要在 <code>YSFOptions</code> 中设置 <code>savePowerConfig</code>。从版本3.1.0开始，该选项默认开启，并使用默认间隔。</p>
<p>在咨询客服时，SDK 会保持长连接以便及时收到推送。当一次会话结束后，用户极有可能还会继续发起咨询会话，同时客服也很有可能会主动发起会话，因此，一次会话结束后，长连接可以在继续保持一段时间(<code>SavePowerConfig.activeDelay</code>)，以便及时收到消息，同时也可以减少重新连接造成的消耗。如果在这段时间内，再也没有开始过会话，则在计时结束后即可转入省电模式。根据用户配置，省电模式分为两种状态：</p>
<ol>
<li>推送模式：用户需要在七鱼的管理后台配置推送服务器，且 <code>SavePowerConfig.customPush</code> 设置为 true。此时，如果有新消息，会自动转到后台配置的推送通道上。由于推送不受 SDK 控制，因此收到推送后 SDK 不会自动建立长连接，需要用户进入咨询界面后，才会建立长连接。开启自定义推送后，还需要设置推送的设备 ID：<code>SavePowerConfig.deviceIdentifier</code>。在七鱼推送的消息结构体中，会包含该字段。 </li>
<li>轮询模式：SDK 每隔 <code>SavePowerConfig.checkInterval</code> 秒去服务器检测一次有没有新消息。如果有新消息，会自动建立长连接，并收取新消息，弹出通知。</li>
</ol>
<h3 id="配置推送服务器地址">配置推送服务器地址</h3><p>客服发送消息给用户，而用户此时已经转入推送模式后，消息将被推送给开发者的服务器端，然后再由开发者推送到 APP 端。</p>
<p>要配置推送服务器，请使用管理员帐号登录七鱼管理后台，在「设置」 -&gt; 「APP设置」 -&gt; 「添加/编辑APP」中设置。</p>
<p><img src="./images/android/android_push_setting.png" alt="推送服务器配置"></p>
<blockquote>
<p>开发者服务器收到推送请求后，应对立即返回一个 <strong>空字符串</strong> 告诉七鱼服务器。七鱼服务器发出 POST 请求后，如果在 10 秒内收不到响应，或者收到的响应非空，会断掉连接，并且重新发起请求，总共重试 2 次。 如果连续 10 次都推送失败，该推送服务器 url 将被暂停推送 1 个小时。</p>
</blockquote>
<h3 id="推送消息数据结构">推送消息数据结构</h3><p>当有消息需要推送时，七鱼服务器会向开发者设置的服务器地址发送推送消息，方法类型为 POST，数据格式为 JSON 。</p>
<p>POST 请求会包含以下参数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">nonce</td>
<td style="text-align:left">随机数字符串</td>
</tr>
<tr>
<td style="text-align:left">time</td>
<td style="text-align:left">当前 UTC 时间戳，从 1970 年 1 月 1 日 0 点 0 分 0 秒开始到现在的秒数</td>
</tr>
<tr>
<td style="text-align:left">checksum</td>
<td style="text-align:left">SHA1(AppSecret + nonce + time), 三个参数拼接的字符串，进行SHA1哈希计算，转化成16进制字符(String，小写)</td>
</tr>
</tbody>
</table>
<p>其中，checksum 可用于校验该请求是否由七鱼服务器发出，出于安全性考虑，还应根据 time 参数校验 checksum 的有效期，超过一定时间（比如 5 分钟）的请求也应判定为非法。请确认发起请求的服务器是与标准时间同步的，比如有NTP服务。</p>
<p><strong>重要提示: 本文档中提供的所有接口均面向开发者服务器端调用，用于计算CheckSum的AppSecret开发者应妥善保管,可在应用的服务器端存储和使用，但不应存储或传递到客户端，也不应在网页等前端代码中嵌入。</strong></p>
<p>计算 checksum 的 java 示例代码如下：</p>
<pre><code class="lang-java"> <span class="hljs-keyword">public</span> class QiyuPushCheckSum {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">char</span>[] HEX_DIGITS = {<span class="hljs-string">'0'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'6'</span>, <span class="hljs-string">'7'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'9'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span>};

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> encode(<span class="hljs-keyword">String</span> appSecret, <span class="hljs-keyword">String</span> nonce, <span class="hljs-keyword">String</span> time) {
        <span class="hljs-keyword">String</span> content = appSecret + nonce + time;
        <span class="hljs-keyword">try</span> {
            MessageDigest messageDigest = MessageDigest.getInstance(<span class="hljs-string">"sha1"</span>);
            messageDigest.update(content.getBytes());
            <span class="hljs-keyword">return</span> getFormattedText(messageDigest.digest());
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> getFormattedText(<span class="hljs-built_in">byte</span>[] bytes) {
        <span class="hljs-built_in">int</span> len = bytes.length;
        StringBuilder buf = <span class="hljs-keyword">new</span> StringBuilder(len * <span class="hljs-number">2</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) {
            buf.<span class="hljs-built_in">append</span>(HEX_DIGITS[(bytes[j] &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0f</span>]);
            buf.<span class="hljs-built_in">append</span>(HEX_DIGITS[bytes[j] &amp; <span class="hljs-number">0x0f</span>]);
        }
        <span class="hljs-keyword">return</span> buf.toString();
    }
}
</code></pre>
<p>POST 请求的内容为 JSON 格式，编码格式为 UTF-8，其各个字段说明如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">字段说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">content</td>
<td style="text-align:left">推送的消息内容</td>
</tr>
<tr>
<td style="text-align:left">time</td>
<td style="text-align:left">消息的发出时间</td>
</tr>
<tr>
<td style="text-align:left">messageId</td>
<td style="text-align:left">消息的唯一 ID，当消息有重发时，开发者的推送服务器可依据此去重。</td>
</tr>
<tr>
<td style="text-align:left">staffName</td>
<td style="text-align:left">说话的客服昵称</td>
</tr>
<tr>
<td style="text-align:left">deviceIdentifier</td>
<td style="text-align:left">消息发送对象用户的 deviceIdentifier</td>
</tr>
<tr>
<td style="text-align:left">package</td>
<td style="text-align:left">消息接收对象 APP 的 package name</td>
</tr>
</tbody>
</table>
<h2 id="自定义响应事件">自定义响应事件</h2><p>为了让用户在使用七鱼 SDK 时拥有更大的灵活性，我们将持续添加更多的事件自定义响应接口。</p>
<h3 id="URL链接点击响应">URL链接点击响应</h3><p>如果用户或者客服发送的文本消息中带有 URL 链接，SDK 将会解析出该链接。用户点击这个链接后，SDK 默认会打开系统的浏览器，并访问这个 URL。同时 SDK 提供了一个配置选项，允许应用自己处理这个点击事件，用于在应用的内置浏览器中打开链接，以及做钓鱼网址过滤等等场景。</p>
<p>设置自定义的链接点击响应需要在初始化 SDK 时，为 <code>YSFOptions</code> 的 <code>onMessageItemClickListener</code> 赋值：</p>
<pre><code><span class="hljs-comment">// 初始化代码</span>
<span class="hljs-comment">// YSFOptions options = new YSFOptions();</span>
OnMessageItemClickListener messageItemClickListener = <span class="hljs-keyword">new</span> OnMessageItemClickListener() {
    <span class="hljs-comment">// 响应 url 点击事件</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onURLClicked(Context context, <span class="hljs-keyword">String</span> url) {
        <span class="hljs-comment">// 打开内置浏览器等动作</span>
    }
}
options.onMessageItemClickListener = messageItemClickListener;

<span class="hljs-comment">// ... 其他初始化代码</span>
<span class="hljs-comment">// Unicorn.init(this, "你的appid", options, new UILImageLoader());</span>
</code></pre><h2 id="平台商家企业">平台商家企业</h2><p>网易七鱼在 V3.2 版本中加入了平台商家企业的支持，平台商家就是类似京东，天猫一类的企业，下属很多其他的第三方商家，每个第三方商家都能够独立管理自己的客服，平台不直接管理客服的分配，绩效等日常工作。如果您不是平台商家企业，可以忽略这部分内容。</p>
<p>本节内容仅仅介绍平台电商接入的相关知识，所有内容是在前面内容基础上编写的，有关 SDK 接入，客服分配，UI 定制等基础知识，请先阅读前文内容。</p>
<h3 id="指定商家">指定商家</h3><p>平台商家在申请客服时需要指定商家ID，需要在打开会话界面时传入的<code>ConsultSource</code>中指定<code>shopId</code>，<code>shopId</code>为企业在管理后台创建商家时填入的商家ID。如果不指定<code>shopId</code>将默认申请平台企业下的客服。</p>
<h3 id="商家入口和最近联系商家入口">商家入口和最近联系商家入口</h3><p>七鱼客服SDK可以在会话界面添加商家入口和最近联系商家列表入口（以下简称会话列表），商家入口位于评价按钮的左侧，会话列表入口位于消息流的右上角以浮层模式展现。</p>
<p>如果需要开启商家入口，需要在打开会话界面时传入的<code>ConsultSource</code>中指定<code>shopEntrance</code>，如果不指定将不显示商家入口。<code>ShopEntrance</code>中的字段通过<code>ShopEntrance.Builder</code>设置，包含如下信息</p>
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">logo</td>
<td style="text-align:left">String</td>
<td style="text-align:left">商家logo url</td>
<td style="text-align:left">图片地址</td>
</tr>
<tr>
<td style="text-align:left">name</td>
<td style="text-align:left">String</td>
<td style="text-align:left">商家名称</td>
<td style="text-align:left">最多显示三个字符超出将显示“xx...”</td>
</tr>
</tbody>
</table>
<p>如果需要开启会话列表入口，需要在<code>ConsultSource</code>中指定<code>sessionListEntrance</code>，如果不指定将不显示会话列表入口。<code>SessionListEntrance</code>中的字段通过<code>SessionListEntrance.Builder</code>设置，包含如下信息</p>
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">imageResId</td>
<td style="text-align:left">DrawableRes资源id</td>
<td style="text-align:left">入口图片资源id</td>
<td style="text-align:left">建议为半透明图片，如果不设置将显示默认图片</td>
</tr>
<tr>
<td style="text-align:left">position</td>
<td style="text-align:left">Position枚举类型</td>
<td style="text-align:left">入口位置</td>
<td style="text-align:left">目前包含TOP_LEFT和TOP_RIGHT，即屏幕左上角和右上角，如果不设置将默认位于右上角</td>
</tr>
</tbody>
</table>
<p>同时，需要在初始化 SDK 时，为<code>YSFOptions</code>的<code>onShopEventListener</code>赋值，用于用户点击商家入口和会话列表入口时做出响应，示例代码如下</p>
<pre><code>YSFOptions options = <span class="hljs-keyword">new</span> YSFOptions();
options.onShopEventListener = <span class="hljs-keyword">new</span> OnShopEventListener() {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">onShopEntranceClick</span><span class="hljs-params">(Context context, String shopId)</span> </span>{
        <span class="hljs-comment">// 点击商家入口响应</span>
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">onSessionListEntranceClick</span><span class="hljs-params">(Context context)</span> </span>{
        <span class="hljs-comment">// 点击会话列表入口响应，以下为示例代码</span>
        SessionListActivity.start(context);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
};
</code></pre><h3 id="最近联系商家列表">最近联系商家列表</h3><ul>
<li>获取最近联系商家列表（以下简称会话列表），可用于展示会话列表<pre><code><span class="hljs-comment"><span class="markdown">/**
<span class="hljs-bullet">* </span>获取最近联系商家列表
<span class="hljs-bullet">*
</span><span class="hljs-bullet">* </span>@return 最近联系商家列表
*/</span></span>
<span class="hljs-built_in">List</span>&lt;Session&gt; sessionList = POPManager.getSessionList();
</code></pre>该接口返回一个<code>Session</code>列表，<code>Session</code>是一个包含会话信息的接口，该接口包含的方法如下</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">返回类型</th>
<th style="text-align:left">方法说明</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">getContactId()</td>
<td style="text-align:left">String</td>
<td style="text-align:left">获取商家ID</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">getMsgStatus()</td>
<td style="text-align:left">MsgStatusEnum</td>
<td style="text-align:left">获取最后一条消息状态</td>
<td style="text-align:left">MsgStatusEnum为消息状态，包含发送中、已发送等</td>
</tr>
<tr>
<td style="text-align:left">getUnreadCount()</td>
<td style="text-align:left">int</td>
<td style="text-align:left">获取商家的未读消息条数</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">getContent()</td>
<td style="text-align:left">String</td>
<td style="text-align:left">获取最后一条消息的预览内容</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">getTime()</td>
<td style="text-align:left">long</td>
<td style="text-align:left">获取最后一条消息的时间戳</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">getSessionStatus()</td>
<td style="text-align:left">SessionStatusEnum</td>
<td style="text-align:left">获取会话状态</td>
<td style="text-align:left"><code>v3.3新增</code> SessionStatusEnum为会话状态，如会话中、排队中等</td>
</tr>
</tbody>
</table>
<ul>
<li><p>删除最近联系商家记录</p>
<pre><code><span class="hljs-comment"><span class="markdown">/**
<span class="hljs-bullet">* </span>删除最近联系商家记录
<span class="hljs-bullet">*
</span><span class="hljs-bullet">* </span>@param shopId          商家ID
<span class="hljs-bullet">* </span>@param clearMsgHistory 是否同时清空消息记录
*/</span></span>
POPManager.deleteSession(<span class="hljs-built_in">String</span> shopId, boolean clearMsgHistory);
</code></pre></li>
<li><p>监听会话列表更新</p>
<pre><code>/**
* 注册/注销最近联系商家列表更新监听器（添加、删除、新消息等）
*
* @param <span class="hljs-keyword">add</span><span class="bash"> <span class="hljs-literal">true</span>，注册；否则注销，请务必在关闭界面时注销此监听器
</span>*/
POPManager.addOnSessionListChangedListener(OnSessionListChangedListener listener, boolean <span class="hljs-keyword">add</span><span class="bash">);</span>
</code></pre><p><code>OnSessionListChangedListener</code>包含会话更新和会话删除回调</p>
<pre><code><span class="hljs-comment">/**
* 商家会话列表监听器
*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">OnSessionListChangedListener</span> {
  <span class="hljs-comment">/**
   * 商家会话发生变化（更新/添加）
   *
   * @param updateSessionList 变化的商家会话列表
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onSessionUpdate</span>(<span class="hljs-params">List&lt;Session&gt; updateSessionList</span>)</span>;

  <span class="hljs-comment">/**
   * 删除商家会话
   *
   * @param shopId 商家ID
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onSessionDelete</span>(<span class="hljs-params">String shopId</span>)</span>;
}
</code></pre><p>开发者需要在回调中处理会话列表更新的逻辑，以同步更新界面。</p>
</li>
</ul>
<h3 id="获取商家信息">获取商家信息</h3><p>由于七鱼SDK对会话和商家信息的管理是独立的，因此在<code>POPManager.getSessionList()</code>接口返回的信息中没有包含商家信息，如果要获取商家信息，需要调用以下接口</p>
<pre><code>/**
 * 根据商家ID获取商家信息，如名称，logo
 *
 * <span class="hljs-meta">@param</span> shopId 商家ID
 * <span class="hljs-meta">@return</span> 如果用户联系过该商家，返回商家信息，否则返回 <span class="hljs-literal">null</span>
 */
ShopInfo shopInfo = POPManager.getShopInfo(String shopId);
</code></pre><p><code>ShopInfo</code>接口包含如下方法</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">返回类型</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">getAccount()</td>
<td style="text-align:left">String</td>
<td style="text-align:left">获取商家ID</td>
<td style="text-align:left">即查询商家信息时传入的shopId</td>
</tr>
<tr>
<td style="text-align:left">getName()</td>
<td style="text-align:left">String</td>
<td style="text-align:left">获取商家名称</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">getAvatar()</td>
<td style="text-align:left">String</td>
<td style="text-align:left">获取商家logo</td>
<td style="text-align:left">图片地址</td>
</tr>
</tbody>
</table>
<h2 id="变更记录">变更记录</h2><h3 id="V3.13.0(2017-12-26)">V3.13.0(2017-12-26)</h3><p><strong>新增</strong></p>
<ol>
<li>增加人工客服模式下的订单选择入口</li>
</ol>
<h3 id="V3.12.0(2017-11-16)">V3.12.0(2017-11-16)</h3><p><strong>新增</strong></p>
<ol>
<li>增加指定机器人客服</li>
<li>增加发送正在输入的内容到客服端</li>
<li>支持 Android 8.1</li>
</ol>
<p><strong>修改</strong></p>
<ol>
<li>SDK 改为异步初始化，提升启动速度</li>
</ol>
<h3 id="V3.11.1(2017-10-17)">V3.11.1(2017-10-17)</h3><p><strong>新增</strong></p>
<ol>
<li>添加静默访客结束会话提示</li>
</ol>
<h3 id="V3.10.0(2017-09-07)">V3.10.0(2017-09-07)</h3><p><strong>新增</strong></p>
<ol>
<li>增加会话超时提醒</li>
<li>一触即达增加卡片模板</li>
</ol>
<p><strong>修改</strong></p>
<ol>
<li>修复用户评价时可能会FC的问题</li>
<li>修复平台商户的名字包含<code>&#39;</code>时会FC的问题</li>
<li>修复使用 Android Studio 3.0 测试版本时编译失败的问题</li>
</ol>
<h3 id="V3.9.5(2017-08-15)">V3.9.5(2017-08-15)</h3><p><strong>新增</strong></p>
<ol>
<li>增加对客服主动邀请评价的支持</li>
<li>增加对自定义文案的支持</li>
</ol>
<h3 id="V3.9.0(2017-07-20)">V3.9.0(2017-07-20)</h3><p><strong>新增</strong></p>
<ol>
<li>增加对留言功能可关闭的支持。</li>
<li>一触即达增加自动生成工单和图文混排等模板。</li>
<li>UI自定义中增加标题文字居中选项。</li>
</ol>
<h3 id="V3.7.1(2017-06-22)">V3.7.1(2017-06-22)</h3><p><strong>修改</strong></p>
<ol>
<li>修复在 OPPO 手机上后台自启动时因为 startService 抛出异常导致初始化失败的问题。</li>
<li>修复在小米手机上因为 AlarmManager.set 接口抛出安全异常导致崩溃的问题。</li>
<li>修正 APP 使用 360 加固后初始化时调用 getAnnotation 接口可能会失败，进而导致崩溃的问题。</li>
<li>修正 OPPO 手机上 bindService 可能会失败的问题。</li>
<li>修正在某些网络环境下，底层网络解包会抛出异常，导致崩溃的问题。</li>
</ol>
<h3 id="V3.7.0(2017-05-24)">V3.7.0(2017-05-24)</h3><p><strong>新增</strong></p>
<ol>
<li>增加对富媒体消息的支持。</li>
<li>增加对机器人回答评价功能。</li>
</ol>
<h3 id="V3.6.1(2017-05-10)">V3.6.1(2017-05-10)</h3><p><strong>修改</strong></p>
<ol>
<li>修复在系统版本低于 7.0 的手机上可能无法正常拍照的问题。</li>
</ol>
<h3 id="V3.6.0(2017-04-27)">V3.6.0(2017-04-27)</h3><p><strong>修改</strong></p>
<ol>
<li>修复部分手机写 log 可能造成崩溃的问题。</li>
</ol>
<h3 id="V3.5.5(2017-04-10)">V3.5.5(2017-04-10)</h3><p><strong>新增</strong></p>
<ol>
<li>增加访客端主动退出会话和退出排队的设置。</li>
</ol>
<p><strong>修改</strong></p>
<ol>
<li>打开会话时无需传入 authToken 字段。</li>
<li>汇报用户信息增加回调接口，用于确认设置是否成功。</li>
<li>修正在 targetSdkVersion 大于等于24时，系统版本大于等于 7.0 的手机不能打开拍照页面的问题。</li>
</ol>
<h3 id="V3.5.0(2017-03-28)">V3.5.0(2017-03-28)</h3><p><strong>新增</strong></p>
<ol>
<li>增加服务直达功能。</li>
<li>增加 VIP 等级设置。</li>
<li>请求客服和汇报用户信息增加 authToken 校验字段。</li>
<li>增加崩溃和异常后的日志反馈功能。</li>
</ol>
<h3 id="V3.4.0(2017-02-21)">V3.4.0(2017-02-21)</h3><p><strong>新增</strong></p>
<ol>
<li>增加对文件类型消息的支持。</li>
<li>增加清除缓存的接口。</li>
</ol>
<p><strong>修改</strong></p>
<ol>
<li>修正写 log 时可能的崩溃。</li>
</ol>
<h3 id="V3.3.0(2017-01-20)">V3.3.0(2017-01-20)</h3><p><strong>新增</strong></p>
<ol>
<li>会话列表中增加会话状态。</li>
</ol>
<p><strong>修改</strong></p>
<ol>
<li>使用 MappedByteBuffer 替代直接文件写入，优化 log 性能。</li>
<li>修复一些非常偶现的崩溃，包括：从老版本升级并关闭 sdkIconContainer 导致的崩溃，因线程竞争导致的登录状态报告时候的崩溃等。</li>
<li>进程间唤起方式由 Broadcast 改为 Service，避免极个别机型上收到消息不能唤起 UI 进程的问题。</li>
</ol>
<h3 id="V3.2.0(2017-01-04)">V3.2.0(2017-01-04)</h3><p><strong>新增</strong></p>
<ol>
<li>新增平台电商企业接入控制，增加 POPManager 接口，增加获取访客会话列表功能。</li>
</ol>
</div>
</div>

<script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA1443074214845'],['_setLocalGifPath', '/UA1443074214845/__utm.gif'],['_setLocalServerMode']);
    _gaq.push(['_addOrganic','baidu','word']);_gaq.push(['_addOrganic','soso','w']);_gaq.push(['_addOrganic','youdao','q']);
    _gaq.push(['_addOrganic','sogou','query']);_gaq.push(['_addOrganic','so.360.cn','q']);
    _gaq.push(['_trackPageview']);_gaq.push(['trackPageLoadTime']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = '/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script>

<!--网易DA-->
<script>
    (function(i,s,ob,g,r,a,m)
    {
        i['AnalyticsObject']=r;

        i[r] = i[r] || function()
            {
                (i[r].ops = i[r].ops || []).push(arguments);
            }

        a = s.createElement(ob);
        a.type = "text/javascript";
        m = s.getElementsByTagName(ob)[0];
        a.async=false;
        a.src=g;
        m.parentNode.insertBefore(a,m);
    })(window, document, 'script', '//rev.da.netease.com/da.js?t='+ parseInt((new Date().getTime())/1000000), '_dapush');

    _dapush('create','DA-B7C2-372B39F3906C'); //其中，DA-A250-E78A2EEA7B9E是推广分析系统通过uuid生成的唯一标识产品的序列,不同产品此序列不同

    _dapush('page_view');

</script>

<script>function lg(n,p,l){_gaq.push(['_trackEvent',n||'',p||'',l||'']);}</script>
<script src="./js/jquery.min.js"></script>
<script src="./js/ZeroClipboard.min.js"></script>
<script src="./js/doc.js"></script>
</body>
</html>
